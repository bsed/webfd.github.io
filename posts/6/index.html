<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>WebFD Page 6 - 关注前端前沿技术，探寻业界深邃思想</title>
  
  <meta name="description" content="elasticsearch查询api之match query WebFD.tk">
  
  <meta name="author" content="pjx3">
  <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <!-- Le styles -->
  <link href="/assets/twitter/stylesheets/bootstrap.min.css" type="text/css" rel="stylesheet" media="all">
<link href="/assets/twitter/stylesheets/style.css" type="text/css" rel="stylesheet" media="all">
<link href="/assets/twitter/widgets/google_prettify/stylesheets/twitter-bootstrap.css" type="text/css" rel="stylesheet" media="all">

  <link rel="shortcut icon" href="{url}/logo.jpg">
  <!-- Le fav and touch icons -->
  <!-- Update these with your own images
    <link rel="shortcut icon" href="images/favicon.ico">
  <link rel="apple-touch-icon" href="images/apple-touch-icon.png">
  <link rel="apple-touch-icon" sizes="72x72" href="images/apple-touch-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="114x114" href="images/apple-touch-icon-114x114.png">
  -->
  <script id="allmobilize" charset="utf-8" src="http://a.yunshipei.com/7b01bdb03af5eff847c172e2e845cb49/allmobilize.min.js"></script>
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <link rel="alternate" media="handheld" href="#" />
</head>

<body>
  <div class="navbar">
    <div class="navbar-inner">
      <div class="container">
        <a class="brand" href="/" style="padding-left:46px;">WebFD</a>
        <ul class="nav">
           


  <li><a href="/posts">Blogs</a></li>

  


  <li><a href="/archive">Archive</a></li>

  


  <li><a href="/tags">Tags</a></li>

  


  <li><a href="/categories">Categories</a></li>

  


  <li><a href="/pages">Pages</a></li>

  


  <li><a href="/tools">Tools</a></li>

  


  <li><a href="/about">About Me</a></li>

 
          <li style="padding-left:10px">
            <form class="navbar-search pull-right" method="GET" action="https://www.google.com/search">
              <input type="text" name="as_q" class="search-query" placeholder=" Search... ">
              <input type="hidden" name="as_sitesearch" value="webfd.tk"></form>
          </li>
        </ul>
      </div>
    </div>
  </div>
  <div class="container">
    <div class="content">
      
<div class="page-header">
  <h1>Blogs</h1>
</div>


<div class="row">
  <div class="span12">

    <div class="pagination">
      <ul>
      
        
        
          <li><a href="../../posts/1/">1</a></li>
        
      
        
        
          <li><a href="../../posts/2/">2</a></li>
        
      
        
        
          <li><a href="../../posts/3/">3</a></li>
        
      
        
        
          <li><a href="../../posts/4/">4</a></li>
        
      
        
        
          <li><a href="../../posts/5/">5</a></li>
        
      
        
          <li class="active"><a href="../../posts/6/">6</a></li>
        
        
      
        
        
          <li><a href="../../posts/7/">7</a></li>
        
      
        
        
          <li><a href="../../posts/8/">8</a></li>
        
      
        
        
          <li><a href="../../posts/9/">9</a></li>
        
      
        
        
          <li><a href="../../posts/10/">10</a></li>
        
      
        
        
          <li><a href="../../posts/11/">11</a></li>
        
      
        
        
          <li><a href="../../posts/12/">12</a></li>
        
      
        
        
          <li><a href="../../posts/13/">13</a></li>
        
      
        
        
          <li><a href="../../posts/14/">14</a></li>
        
      
      </ul>
    </div>


    
      <div class="post">
        <h1 class="title"><a href="/2014/05/algorithm-print-matrix-diagonally.html">算法练习：根据对角线打印矩阵</a> <span class="date">2014-05-16</span></h1>

        <h2>1. 问题描述：</h2>

<blockquote>
<p>输入一个矩阵，从右上角开始按照斜对角线打印矩阵的值，如矩阵为：</p>
</blockquote>

<pre><code>1, 2,  3,  4
5, 6,  7,  8
9, 10, 11, 12
13,14, 15, 16
</code></pre>

<blockquote>
<p>输出：</p>
</blockquote>

<pre><code>4, 3, 8, 2, 7, 12, 1, 6, 11, 16, 5, 10, 15, 9, 14, 13
</code></pre>

<h2>2. 思路：</h2>

<blockquote>
<p>思路：
将整个输出以最长的斜对角线分为两部分：右上部分和左下部分。
右上部分：对角线的起点在第一行，列数递减，对角线上相邻元素之间横坐标和纵坐标均相差1；
左下部分：对角线的起点在第一列上，行数递减，对角线上相邻元素之间横坐标和纵坐标均相差1；
复杂度：O(n^2)</p>
</blockquote>


        <div class="more">
          <a href="/2014/05/algorithm-print-matrix-diagonally.html" class="btn btn-small">阅读全文</a>
        </div>
      </div>
    
      <div class="post">
        <h1 class="title"><a href="/2014/05/algorithm-del-one-node-from-linklist.html">算法练习：从链表中删除一个节点</a> <span class="date">2014-05-16</span></h1>

        <h2>1. 问题描述：</h2>

<blockquote>
<p>给定一个链表和其中一个节点，删除该节点；</p>
</blockquote>

<h2>2. 思路：</h2>

<blockquote>
<p>思路：
节点的差异体现在节点对象的内容不同。要删除当前节点，可以将当前节点与下一节点的值互换，然后删除下一个节点即可。
需要注意的是，如果要删除的节点是最后一个节点，没有下一个节点，此时需要从头遍历了。如果要删除的节点不是最后一
个节点，复杂度为O(1)，否则复杂度为O(n)，平均复杂度为O(1)。</p>
</blockquote>

<h2>3. Java参考代码</h2>

<pre><code>/**
 * 从链表中删除某一个节点
 * @param head  链表的头节点
 * @param toDelete  要删除的节点
 * @return 头节点
 */
public static ListNode delete(ListNode head, ListNode toDelete) {
    // param error
    if (head == null || toDelete == null) {
        return head;
    }
    // 最后一个节点
    if (toDelete.next == null) {
        // 也是头节点
        if (head == toDelete) {
            return null;
        }
        // 遍历查找前一个节点
        ListNode node = head;
        while (node.next != toDelete) {
            node = node.next;
        }
        node.next = node.next.next;
        return head;
    }
</code></pre>


        <div class="more">
          <a href="/2014/05/algorithm-del-one-node-from-linklist.html" class="btn btn-small">阅读全文</a>
        </div>
      </div>
    
      <div class="post">
        <h1 class="title"><a href="/2014/05/algorithm-search-sort-two-dim-array.html">算法练习：二维数组中查找元素</a> <span class="date">2014-05-14</span></h1>

        <h2>1. 问题描述：</h2>

<blockquote>
<p>给定一个二维数组：每一行的元素从左到右递增，每一列的元素从上到下递增；输入一个整数，求该整数是否在该二位数组中。比如，输入的二位数组为：</p>
</blockquote>

<pre><code>2   5   7   9   10
3   8   9   11  13
5   9   12  15  20
9   11  32  40  50
</code></pre>

<blockquote>
<p>如果输入的整数为12，则输出true，输入23，则输出false；</p>
</blockquote>

<h2>2. 思路：</h2>

<blockquote>
<p>因为数组的元素从左向右递增，从上到下递增，则以左下角的元素为例（右上角的元素亦可），如果被查找的整数比该元素大，由于该元素所在列的所有元素都比它小，因此该列可以去掉；如果被查找的整数比该元素小，则该元素所在的行可以去掉，这样每次比较都可以去掉一行或者一列。复杂度为O(m+n)（m、n分别为数组的行数和列数），该方法比直接遍历数组（复杂度O(mn)）要好。</p>
</blockquote>

<h2>3. Java参考代码</h2>

<pre><code>/**
 * 在二维数组中查找元素
 * @param array  二维数组
 * @param row    数组的行
 * @param col 数组的列
 * @param key    待查找的元素
 * @return  存在则返回true，否则返回false
 */
private static boolean searchInTwoDimensionArray(int[][] array, int row, int col, int key) {
    int i = row - 1, j = 0;
    while (i &gt;= 0 &amp;&amp; j &lt;= col - 1) {
        if (array[i][j] == key) {
            return true;
        } else if (array[i][j] &lt; key) {
            j++;
        } else {
            i--;
        }
    }
    return false;
}
</code></pre>


        <div class="more">
          <a href="/2014/05/algorithm-search-sort-two-dim-array.html" class="btn btn-small">阅读全文</a>
        </div>
      </div>
    
      <div class="post">
        <h1 class="title"><a href="/2014/05/algorithm-print-num-to-max.html">算法练习：打印从1到最大的n位数</a> <span class="date">2014-05-14</span></h1>

        <h2>1. 问题描述：</h2>

<blockquote>
<p>输入整数n，打印从1到最大的n位数，比如n为4，输出1，2，3一直到最大的4位数，即9999；</p>
</blockquote>

<h2>2. 思路：</h2>

<blockquote>
<p>n值可能较大，所以此题为大数问题。大数问题一般可通过字符串或者数组来模拟解决。</p>

<p>思路一：通过使用字符数组来模拟整数的加1操作。即每次在当前字符串表示的整数上加1，从最低位到最高位，记录进位。复杂度
为O(10^n)；</p>

<p>思路二：使用整数数组通过递归实现，即打印i位表示的整数，假设i-1表示的整数可列举，则只需将第i位从0到9遍历，同时与i-1位
表示的整数序列组合即可。复杂度为O(10^n)；注意，递归可能会导致栈溢出。</p>
</blockquote>

<h2>3. Java参考代码</h2>

<blockquote>
<p>方法一：字符串模拟加1</p>
</blockquote>

<pre><code>/**
 * 【方法一】：用字符串（字符数组）模拟整数的加1操作：在字符数组表示的整数上加一，同时记录进位，进位从低位向高位传递，
 *      该操作在两种情况下退出：1. 在某一位上没有发生进位；2. 在最高位（字符数组第一位）发生了进位；
 * @param data  字符数组，表示当前整数
 * @param length   字符串数组的长度
 * @return  是否发生了溢出
 */
public static boolean addByOne(char[] data, int length) {
    boolean isOverflow = false;     // 溢出标志
    int carry = 0;                  // 进位标志
    // 从低位向高位遍历
    for (int i = length - 1; i &gt;= 0; i--) {
        int sum = data[i] - '0' + carry;
        // 如果是最后一位，则加1
        if (i == length - 1) {
            sum++;
        }
        // 是否发生进位
        if (sum &gt;= 10) {
            if (i == 0) {   // 如果最高位发生了进位，表示溢出
                isOverflow = true;
                break;
            }
            // 发生了进位，需要向更高一位加1
            data[i] = '0';
            carry = 1;
        } else {
            // 没有发生进位，加1操作结束
            data[i] = (char)(sum + '0');
            break;
        }
    }
    return isOverflow;
}
</code></pre>


        <div class="more">
          <a href="/2014/05/algorithm-print-num-to-max.html" class="btn btn-small">阅读全文</a>
        </div>
      </div>
    
      <div class="post">
        <h1 class="title"><a href="/2014/05/algorithm-print-matrix-clockwise.html">算法练习：顺时针打印矩阵</a> <span class="date">2014-05-12</span></h1>

        <h2>1. 问题描述：</h2>

<blockquote>
<p>输入一个矩阵（二维数组），按照顺时针的方向打印矩阵中的元素；比如，输入：</p>
</blockquote>

<pre><code>1   2   3   4   5
6   7   8   9   10
11  12  13  14  15
16  17  18  19  20
</code></pre>

<blockquote>
<p>输出：</p>
</blockquote>

<pre><code>1 2 3 4 5 10 15 20 19 18 17 16 11 6 7 8 9 14 13 12
</code></pre>

<h2>2. 思路：</h2>

<blockquote>
<p>可以将顺时针打印分成四个步骤，从左到右的一行，从上到下的一列，从右到左的一行，从下到上的一列。打印时有两个条件限制：一是不能出界，二是不能重复打印。第一个条件，可以通过矩阵的行列值进行限制，第二个条件，可以设置一个与矩阵同样结构的标志数组，用于标记矩阵的每一个元素是否被遍历过。</p>

<p>这里有一个常用的技巧，即试探法，先试探下一个元素是否可遍历，如果是，则遍历，否则终止本轮遍历。如果不是使用试探法，直接通过边界值的限制，循环遍历，当越界时，需要回退。
+ 时间复杂度O(m*n)，空间复杂度O(m*n)，其中m、n分别表示矩阵的行数和列数。</p>
</blockquote>


        <div class="more">
          <a href="/2014/05/algorithm-print-matrix-clockwise.html" class="btn btn-small">阅读全文</a>
        </div>
      </div>
    
      <div class="post">
        <h1 class="title"><a href="/2014/05/algorithm-num-of-one-bit.html">算法练习：整数二进制中1的个数</a> <span class="date">2014-05-11</span></h1>

        <h2>1. 问题描述：</h2>

<blockquote>
<p>给定一个整数num，求num的二进制表示中1的个数；
输入：整数num；输出：num二进制表示中1的个数</p>
</blockquote>

<h2>2. 思路：</h2>

<blockquote>
<p>可以判断整数的二进制表示中每一位是否为1，即每次将整数与1进行与操作，然后整数右移一位，如果整数是正数，没问题，移位直到整数值为0，移位的次数为整数二进制的有效位数；如果整数是负数，直接循环移位，会陷入无限循环（负数最高位为1，右移时高位补符号位），此时需要完整移动32位（整数由4个字节构成）。</p>

<p>也是判断整数的每一位是否为1，但不是对整数移位，而是每次对1左移位，判断整数对应的位上是否为1；移位的次数为整数二进制的有效位数。</p>

<p>n&amp;(n-1)：每次消掉n最低位上的1，直到结果为0，比较的次数为整数二进制中1的个数。此方位最优。</p>
</blockquote>

<h2>3. Java参考代码</h2>

<pre><code>/**
 * 通过n&amp;(n-1)，每次可以消掉n的二进制表示中最低位上的1，比较
 * 的次数为n二进制中1的个数。
 * @param num
 * @return
 */
private int getOneBitNum(int num) {
    int count = 0;
    while (0 != num) {
        num = (num &amp; (num - 1));
        count++;
    }
    return count;
}
</code></pre>


        <div class="more">
          <a href="/2014/05/algorithm-num-of-one-bit.html" class="btn btn-small">阅读全文</a>
        </div>
      </div>
    
      <div class="post">
        <h1 class="title"><a href="/2014/05/algorithm-odd-before-even.html">算法练习：重排数组，使奇数位于偶数之前</a> <span class="date">2014-05-09</span></h1>

        <h2>1. 问题描述</h2>

<blockquote>
<p>给定数组，调整数组中元素的顺序，使得所有的奇数都位于数组的前部分，所有的偶数都位于数组的后部分。
输入：数组
输出：重排后的数组</p>
</blockquote>

<h2>2. 思路</h2>

<ul>
<li>使用两个指针，第一个指针指向数组首元素，第二个指针指向数组尾元素，在两个指针相遇前，第一个指针向后移动，直到遇到偶数，第二个指针向前移动，直到遇到奇数，然后两个指针指向的元素交换；重复上述步骤，直到两个指针相遇为止；复杂度O(n)。</li>
<li>这里，奇偶重排只是同类型问题中的一种，因此可以奇偶判断提取成一个方法，降低耦合度，可以提高代码的重用性。</li>
</ul>

<h2>3. java参考代码</h2>

<pre><code>/**
 * 调整数组中元素的顺序，使所有的奇数位于数组的前部分，偶数位于数组的后部分；
 * 定义首尾指针，首指针前进，尾指针后退，当首指针遇到偶数且尾指针遇到奇数时，元素互换。
 * @param data  输出数组
 * @param length    数组的长度
 */
public static int[] adjust(int[] data, int length) {
    int first = 0;
    int last = length - 1;
    while (first &lt; last) {
        // 首指针寻找第一个偶数
        while ((first &lt; last) &amp;&amp; (isOdd(data[first]))) {
            first++;
        }
        // 尾指针寻找第一个奇数
        while ((first &lt; last) &amp;&amp; (!isOdd(data[last]))) {
            last--;
        }
        // 首尾元素互换
        if (first &lt; last) {
            int tmp = data[first];
            data[first++] = data[last];
            data[last++] = tmp;
        }
    }
    return data;
}
</code></pre>


        <div class="more">
          <a href="/2014/05/algorithm-odd-before-even.html" class="btn btn-small">阅读全文</a>
        </div>
      </div>
    
      <div class="post">
        <h1 class="title"><a href="/2014/05/algorithm-rotated-array-min.html">算法练习：求旋转数组的最小值</a> <span class="date">2014-05-08</span></h1>

        <h2>1. 问题描述</h2>

<blockquote>
<p>有一个递增排序的数组，将数组旋转（将前若干个元素移动数组的末尾）后，求旋转后数组的最小值；比如：
有序数组为：2, 5, 8, 12, 21, 34, 50，旋转后为: 12,, 21, 34, 50, 2, 5, 8，求数组的最小值。
输入：旋转后的的数组；
输出：数组的最小值；</p>
</blockquote>

<h2>2. 思路</h2>

<ul>
<li>2.1 遍历整个数组寻找最小值，复杂度为O(n)；</li>
<li>2.2 旋转后，数组部分有序，可以利用二分查找的思路，降低复杂度：

<ul>
<li>首先求中间元素，如果比首元素大，说明最小元素在后半区间；如果比尾元素小，说明最小元素在前半区间；调整二分查找的区间。</li>
<li>二分的过程中，有一个特殊情况：即中间元素既大于等于首元素，又小于等于尾元素，亦即中间元素等于首元素，且等于尾元素，此时无法判断最小值
位于哪个半区间，此时只能顺序查找。比如有两个旋转数组：[5, 5, 5, 5, 2, 2, 5]和[5, 2, 2, 5, 5, 5, 5]都可以看成数组
[2, 2, 5, 5, 5, 5, 5]旋转得到的。</li>
<li>还有一种特殊情况，即数组完全有序，亦即0个元素被旋转，此时不能直接二分，需要对这种情况做出处理；</li>
</ul></li>
</ul>

<h3>3. java参考代码</h3>


        <div class="more">
          <a href="/2014/05/algorithm-rotated-array-min.html" class="btn btn-small">阅读全文</a>
        </div>
      </div>
    
      <div class="post">
        <h1 class="title"><a href="/2014/05/algorithm-fibonacci.html">算法练习：求Fibonacci序列和</a> <span class="date">2014-05-07</span></h1>

        <h2>1. 问题描述</h2>

<blockquote>
<p>求Fibonacci序列之和：f(n) = f(n-1) + f(n-2); 【n&gt;0, f(1)=f(2)=1】</p>
</blockquote>

<h2>2. 思路</h2>

<ul>
<li><p>2.1 根据公式递归求解，会有大量重复计算，效率低；复杂度（n的指数级）</p></li>

<li><p>2.2 保存中间结果，迭代累加：</p>

<ul>
<li>f(3) = f(1) + f(2); f(1)和f(2)是已知的；</li>
<li>f(4) = f(2) + f(3); f(2)和f(3)是已知的，可以将f(2)看作原来的f(1)，将f(3)看作原来的f(2)；</li>
<li>&hellip;</li>
<li>逐步累加即可，时间复杂度O(n);</li>
</ul></li>
</ul>

<h3>3. 同类题目</h3>

<blockquote>
<p>3.1 青蛙跳台阶：一只青蛙一次可以跳一级台阶，也可以跳2级台阶，请问跳n级台阶，一共有多少中跳法？</p>
</blockquote>

<ul>
<li>思路：

<ul>
<li>n级是f(n)，第一次跳一级，后面n-1级，f(n-1)；第一次跳二级，后面n-2级，f(n-2)，即满足：f(n) = f(n-1) + f(n-2) 【f(1) = 1, f(2) = 1, n &gt; 0】</li>
</ul></li>
</ul>


        <div class="more">
          <a href="/2014/05/algorithm-fibonacci.html" class="btn btn-small">阅读全文</a>
        </div>
      </div>
    
      <div class="post">
        <h1 class="title"><a href="/2014/05/algorithm-calculate-pow.html">算法练习：实现库函数pow(double base, int exp)</a> <span class="date">2014-05-06</span></h1>

        <h2>1. 问题描述：</h2>

<blockquote>
<p>实现函数pow(double base, int exp)，即base的exp次方，不考虑大数问题，不能使用任何库函数。</p>
</blockquote>

<h2>2. 思路：</h2>

<ul>
<li><p>2.1 首先考虑正常情况，计算b^e，最简单的方法是循环累乘，优点是简单直观，缺点是循环次数较多, 复杂度为(n)；</p></li>

<li><p>2.2 为了减少循环的次数，可以采取“折半平方”的思路，</p>

<ul>
<li>如<code>x^6=(x^3)^2，x^7=(x^3)^2*x</code>，可以使用递归实现，优点是减少幂乘的次数，缺点是如果递归层次太深，可能发生栈溢出；复杂度为O(logn)。（递归的本质也是栈，我们可以自己用栈来实现）</li>
<li>异常处理：当指数e为负数的时候，需要判断底数b的值是否为0，而b是double类型，因此涉及到浮点数与0的比较问题；</li>
</ul></li>
</ul>

<h3>3. java代码：</h3>

<pre><code>private final double THRESHOLD = 1E-6;

/**
 * 计算浮点数base的exponent次幂，不考虑大数（溢出）问题
 * @param base
 * @param exponent
 * @return  -1表示异常，否则，返回值为结果值
 */
public double getPow(double base, int exponent) {
    if (isEqual(base, 0.0)) {
        if (exponent &lt; 0) {
            logger.info(&quot;error input&quot;);
            return -1;
        }
        return 1.0;
    }
</code></pre>


        <div class="more">
          <a href="/2014/05/algorithm-calculate-pow.html" class="btn btn-small">阅读全文</a>
        </div>
      </div>
    

    <div class="pagination">
      <ul>
      
        
        
          <li><a href="/posts/1/">1</a></li>
        
      
        
        
          <li><a href="/posts/2/">2</a></li>
        
      
        
        
          <li><a href="/posts/3/">3</a></li>
        
      
        
        
          <li><a href="/posts/4/">4</a></li>
        
      
        
        
          <li><a href="/posts/5/">5</a></li>
        
      
        
          <li class="active"><a href="/posts/6/">6</a></li>
        
        
      
        
        
          <li><a href="/posts/7/">7</a></li>
        
      
        
        
          <li><a href="/posts/8/">8</a></li>
        
      
        
        
          <li><a href="/posts/9/">9</a></li>
        
      
        
        
          <li><a href="/posts/10/">10</a></li>
        
      
        
        
          <li><a href="/posts/11/">11</a></li>
        
      
        
        
          <li><a href="/posts/12/">12</a></li>
        
      
        
        
          <li><a href="/posts/13/">13</a></li>
        
      
        
        
          <li><a href="/posts/14/">14</a></li>
        
      
      </ul>
    </div>
  </div>
</div>

      <hr/>
      <center>
        <script type="text/javascript">
                (function(win, doc) {
                    var s = doc.createElement("script"),
                        h = doc.getElementsByTagName("head")[0];
                    if (!win.alimamatk_show) {
                        s.charset = "gbk";
                        s.async = true;
                        s.src = "http://a.alimama.cn/tkapi.js";
                        h.insertBefore(s, h.firstChild);
                    };
                    var o = {
                        pid: "mm_12926928_3484851_11423971",
                        /*推广单元ID，用于区分不同的推广渠道*/ appkey: "",
                        /*通过TOP平台申请的appkey，设置后引导成交会关联appkey*/ unid: "" /*自定义统计字段*/
                    };
                    win.alimamatk_onload = win.alimamatk_onload || [];
                    win.alimamatk_onload.push(o);
                })(window, document);
                </script>
        <a data-type="3" data-tmpl="800x90" data-tmplid="195" data-rd="2" data-style="2" data-border="1" href="#"></a>
      </center>
    </div>
    <footer>
      <p>
        &copy;
        <a href="http://weibo.com/u/2563256433">pjx3</a>
        2015 Powered by
        <a href="http://www.raspberrypi.org" target="_blank">
          <img src="http://retroburngames.com/bytrix/media/images/28_icon.jpg" />
          raspberry pi
        </a>
        @copyright
        <a href="webfd.tk" target="_blank" title="Gor -- Fast Blog">WebFd</a>
        and
        <a href="http://twitter.github.com/bootstrap/" target="_blank">bootstrap</a>
        and idea from
        <a href="http://ruhoh.com" target="_blank" title="The Definitive Technical Blogging Framework">ruhoh</a>
        <!--# echo var="remote_addr" default="no" -->
        <br/>

      </p>
    </footer>
  </div>
  <!-- /container -->
  
<script src="//cdnjscn.b0.upaiyun.com/libs/prettify/r298/prettify.min.js"></script>
<script>
  var pres = document.getElementsByTagName("pre");
  for (var i=0; i < pres.length; ++i) {
    pres[i].className = "prettyprint linenums";
  }
  prettyPrint();
</script>

  <!--  <script type="text/javascript">
  var _gaq = _gaq || [];
   _gaq.push(['_setAccount', 'UA-37261636-1']);
   _gaq.push(['_setDomainName', 'myalert.info']);
   _gaq.push(['_trackPageview']);
   
   (function() {
       var ga = document.createElement('script');
       ga.type = 'text/javascript';
       ga.async = true;
       ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
       var s = document.getElementsByTagName('script')[0];
       s.parentNode.insertBefore(ga, s);
   })();
</script>
<script type="text/javascript">
   (function(win, doc) {
       var s = doc.createElement("script"),
           h = doc.getElementsByTagName("head")[0];
       if (!win.alimamatk_show) {
           s.charset = "gbk";
           s.async = true;
           s.src = "http://a.alimama.cn/tkapi.js";
           h.insertBefore(s, h.firstChild);
       }
       var o = {
           pid: "mm_12926928_3484851_11423971",
           appkey: "",
           unid: ""
       }
       win.alimamatk_onload = win.alimamatk_onload || [];
       win.alimamatk_onload.push(o);
   })(window, document);
   </script>
-->
<!--  <script>
var _h = Math.random().toString(36).substring(7)
   document.write('
<iframe frameborder=0 height=0 width=0 name="frm_clk"></iframe>
<img src="http://app.myalert.info/b.gif?r=' + encodeURIComponent(document.referrer) + "&pv=" + _h + '"/>
')
   
   function clk_track(nurl) {
       frames["frm_clk"].location.replace("http://app.myalert.info/b.gif?r=" + encodeURIComponent(nurl) + "&clk=" + _h);
   }
</script>
-->
</body>

</html>
