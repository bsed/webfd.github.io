<?xml version="1.0"  encoding="UTF-8"?>
<rss version="2.0">  <channel>
    <title>WebFD</title>
    <link>http://webfd.tk</link>
    <pubDate>29 May 15 23:27 CST</pubDate>
    <item>
      <title>how did get to reactjs and compare it to angularjs mvc data binding</title>
      <link>http://webfd.tk/js/how-did-get-to-reactjs-and-compare-it-to-angularjs-mvc-data-binding/</link>
      <pubDate>2014-05-18 12:00:00 +0800</pubDate>
      <description>&lt;h2&gt;经典的MVC&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;在一个交互式应用程序中状态的管理是一切罪恶的根源。“传统”的方式是采用MVC架构，或者是一些变种。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;MVC提出你的模型(Model)是检验真理的唯一来源 - 所有的状态都在那里。视图(View)源自模型，并且必须跟模型保持同步。当模型转变时，视图也要同步改变&lt;/p&gt;&#xA;&#xA;&lt;p&gt;最后，用户通过控制器（Controller）控制交互，由它更新模型。到目前为止，这工作地很好。&#xA;&lt;img src=&#34;/assets/images/500px-MVC-Process.svg.png&#34; alt=&#34;500px-MVC-Process.svg&#34; /&gt;&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;当Model改变时重绘View&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;这看起来很简单。首先，我们需要来详细我们的View - 它是一个对DOM的映射。然后，每当用户更新模型时重绘整个DOM，对吧？不幸的是，事情不是这么简单，原因有二：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;DOM 实现上是有状态的, 像input文本的内容。如果你重绘整个DOM, 这部分内容就会丢失。&lt;/li&gt;&#xA;&lt;li&gt;DOM 操作 (像移除插入的结点) 真的非常慢. 持续不断地重绘会导致严重的性能问题。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;所以，我们怎样同步Model和View来避免上面的问题？&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;数据绑定 Data binding&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;在过去3年，框架级别的通用解决方案是采用数据绑定。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;数据绑定是让你的模型和视图，拥有自动同步的能力。通常情况下，是将JavaScript对象和DOM进行同步。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;它通过你的数据声明的组件之间的依赖关系来实现。状态的变化会在整个应用程序中传播并通知所有依赖的对象，然后自动更新。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;让我们来看看它是如何工作的和一些著名的框架。&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;Knockout&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;Knockout主张MVVM模式，并帮助您实现“View”部分：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// View (一个模板)&#xA;&amp;lt;p&amp;gt;First name: &amp;lt;input data-bind=&amp;quot;value: firstName&amp;quot; /&amp;gt;&amp;lt;/p&amp;gt;  &#xA;&amp;lt;p&amp;gt;Last name: &amp;lt;input data-bind=&amp;quot;value: lastName&amp;quot; /&amp;gt;&amp;lt;/p&amp;gt;  &#xA;&amp;lt;h2&amp;gt;Hello, &amp;lt;span data-bind=&amp;quot;text: fullName&amp;quot;&amp;gt; &amp;lt;/span&amp;gt;!&amp;lt;/h2&amp;gt;&#xA;&#xA;// ViewModel (diplay data... and logic?)&#xA;var ViewModel = function(first, last) {  &#xA;  this.firstName = ko.observable(first);&#xA;  this.lastName = ko.observable(last);&#xA;&#xA;  this.fullName = ko.pureComputed(function() {&#xA;      // Knockout 会自动侦听依赖。它知道fullName会依赖firstName和lastName.&#xA;      return this.firstName() + &amp;quot; &amp;quot; + this.lastName();&#xA;  }, this);&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;然后，万事大吉了。改变任一输入的值将触发DOM的变化。你从来不用写数据与视图关连的逻辑代码。效果不错，是吧？&lt;/p&gt;&#xA;&#xA;&lt;p&gt;为什么模型是真理的唯一来源？这个ViewModel应该从哪里获取状态？它是如何知道Model的变化的？这是很有趣的问题。&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;Angular&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;Angular介绍了如果在Model和View之间同步数据。下图来自其文档：&#xA;&lt;img src=&#34;/assets/images/Two_Way_Data_Binding.png&#34; alt=&#34;Two_Way_Data_Binding&#34; /&gt;&#xA;但是&amp;hellip;&amp;hellip;View应该与Model直接通信吗？难道他们是紧耦合的？&lt;/p&gt;&#xA;&#xA;&lt;p&gt;无论如何，让我们来看看Hello World示例：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// View (一个模板) &#xA;&amp;lt;div ng-controller=&amp;quot;HelloController as hello&amp;quot;&amp;gt;  &#xA;  &amp;lt;label&amp;gt;Name:&amp;lt;/label&amp;gt;&#xA;  &amp;lt;input type=&amp;quot;text&amp;quot; ng-model=&amp;quot;hello.firstName&amp;quot;&amp;gt;&#xA;  &amp;lt;input type=&amp;quot;text&amp;quot; ng-model=&amp;quot;hello.lastName&amp;quot;&amp;gt;&#xA;  &amp;lt;h1&amp;gt;Hello !&amp;lt;/h1&amp;gt;&#xA;&amp;lt;/div&amp;gt;&#xA;&#xA;// Controller &#xA;angular.module(&#39;helloApp&#39;, [])  &#xA;.controller(&#39;HelloController&#39;, function() {&#xA;  var hello = this;&#xA;  hello.fullName = function() {&#xA;    return hello.firstName + hello.lastName;&#xA;  };&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;通过这个例子，Controller看起拥有自己的状态，而且表现的像个Model或者一个ViewModel?假设Model是其它的什么东西，它是如何保持跟Controller的同步的呢？&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;data binding的问题&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;数据绑定在小的例子里工作地很好。然而，当你的app不断地迭代时。你可能会碰到下面的问题。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;声明依赖会快速地引入循环&lt;/p&gt;&#xA;&#xA;&lt;p&gt;最常见的问题是在应对状态变化时所产生的副作用。从Flux的这篇报道可以很清楚地了解依赖地狱的蠕变：&#xA;&lt;img src=&#34;/assets/images/mvc_dep_hell.png&#34; alt=&#34;mvc_dep_hell&#34; /&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在这种情况下，你能预测当一个Model发生变化时会发生什么吗？推理是非常非常困难的，因为它的执行次序可能是非常随意的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;模板和显示逻辑被人为地割裂&lt;/p&gt;&#xA;&#xA;&lt;p&gt;视图的作用是什么？呈现的数据显示给用户。ViewModel是干什么的？呈现的数据显示给用户。有什么区别？没有！&lt;/p&gt;&#xA;&#xA;&lt;p&gt;模板分离技术，我不关注〜 皮特·亨特&lt;/p&gt;&#xA;&#xA;&lt;p&gt;最后，一​​个视图组件应该能够操纵它的数据，并能以所希望的格式呈现它。但是，所有的模板语言本质上是残缺的：他们永远不能达到同样的表现力和效能的代码。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;非常简单，&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>how did get to reactjs and compare it to angularjs mvc data binding</title>
      <link>http://webfd.tk/default/how-did-get-to-reactjs-and-compare-it-to-angularjs-mvc-data-binding/</link>
      <pubDate>2014-05-18 12:00:00 +0800</pubDate>
      <description>&lt;h2&gt;经典的MVC&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;在一个交互式应用程序中状态的管理是一切罪恶的根源。“传统”的方式是采用MVC架构，或者是一些变种。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;MVC提出你的模型(Model)是检验真理的唯一来源 - 所有的状态都在那里。视图(View)源自模型，并且必须跟模型保持同步。当模型转变时，视图也要同步改变&lt;/p&gt;&#xA;&#xA;&lt;p&gt;最后，用户通过控制器（Controller）控制交互，由它更新模型。到目前为止，这工作地很好。&#xA;&lt;img src=&#34;/assets/images/500px-MVC-Process.svg.png&#34; alt=&#34;500px-MVC-Process.svg&#34; /&gt;&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;当Model改变时重绘View&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;这看起来很简单。首先，我们需要来详细我们的View - 它是一个对DOM的映射。然后，每当用户更新模型时重绘整个DOM，对吧？不幸的是，事情不是这么简单，原因有二：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;DOM 实现上是有状态的, 像input文本的内容。如果你重绘整个DOM, 这部分内容就会丢失。&lt;/li&gt;&#xA;&lt;li&gt;DOM 操作 (像移除插入的结点) 真的非常慢. 持续不断地重绘会导致严重的性能问题。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;所以，我们怎样同步Model和View来避免上面的问题？&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;数据绑定 Data binding&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;在过去3年，框架级别的通用解决方案是采用数据绑定。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;数据绑定是让你的模型和视图，拥有自动同步的能力。通常情况下，是将JavaScript对象和DOM进行同步。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;它通过你的数据声明的组件之间的依赖关系来实现。状态的变化会在整个应用程序中传播并通知所有依赖的对象，然后自动更新。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;让我们来看看它是如何工作的和一些著名的框架。&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;Knockout&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;Knockout主张MVVM模式，并帮助您实现“View”部分：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// View (一个模板)&#xA;&amp;lt;p&amp;gt;First name: &amp;lt;input data-bind=&amp;quot;value: firstName&amp;quot; /&amp;gt;&amp;lt;/p&amp;gt;  &#xA;&amp;lt;p&amp;gt;Last name: &amp;lt;input data-bind=&amp;quot;value: lastName&amp;quot; /&amp;gt;&amp;lt;/p&amp;gt;  &#xA;&amp;lt;h2&amp;gt;Hello, &amp;lt;span data-bind=&amp;quot;text: fullName&amp;quot;&amp;gt; &amp;lt;/span&amp;gt;!&amp;lt;/h2&amp;gt;&#xA;&#xA;// ViewModel (diplay data... and logic?)&#xA;var ViewModel = function(first, last) {  &#xA;  this.firstName = ko.observable(first);&#xA;  this.lastName = ko.observable(last);&#xA;&#xA;  this.fullName = ko.pureComputed(function() {&#xA;      // Knockout 会自动侦听依赖。它知道fullName会依赖firstName和lastName.&#xA;      return this.firstName() + &amp;quot; &amp;quot; + this.lastName();&#xA;  }, this);&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;然后，万事大吉了。改变任一输入的值将触发DOM的变化。你从来不用写数据与视图关连的逻辑代码。效果不错，是吧？&lt;/p&gt;&#xA;&#xA;&lt;p&gt;为什么模型是真理的唯一来源？这个ViewModel应该从哪里获取状态？它是如何知道Model的变化的？这是很有趣的问题。&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;Angular&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;Angular介绍了如果在Model和View之间同步数据。下图来自其文档：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;但是&amp;hellip;&amp;hellip;View应该与Model直接通信吗？难道他们是紧耦合的？&lt;/p&gt;&#xA;&#xA;&lt;p&gt;无论如何，让我们来看看Hello World示例：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// View (一个模板) &#xA;&amp;lt;div ng-controller=&amp;quot;HelloController as hello&amp;quot;&amp;gt;  &#xA;  &amp;lt;label&amp;gt;Name:&amp;lt;/label&amp;gt;&#xA;  &amp;lt;input type=&amp;quot;text&amp;quot; ng-model=&amp;quot;hello.firstName&amp;quot;&amp;gt;&#xA;  &amp;lt;input type=&amp;quot;text&amp;quot; ng-model=&amp;quot;hello.lastName&amp;quot;&amp;gt;&#xA;  &amp;lt;h1&amp;gt;Hello !&amp;lt;/h1&amp;gt;&#xA;&amp;lt;/div&amp;gt;&#xA;&#xA;// Controller &#xA;angular.module(&#39;helloApp&#39;, [])  &#xA;.controller(&#39;HelloController&#39;, function() {&#xA;  var hello = this;&#xA;  hello.fullName = function() {&#xA;    return hello.firstName + hello.lastName;&#xA;  };&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;通过这个例子，Controller看起拥有自己的状态，而且表现的像个Model或者一个ViewModel?假设Model是其它的什么东西，它是如何保持跟Controller的同步的呢？&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;data binding的问题&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;数据绑定在小的例子里工作地很好。然而，当你的app不断地迭代时。你可能会碰到下面的问题。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;声明依赖会快速地引入循环&lt;/p&gt;&#xA;&#xA;&lt;p&gt;最常见的问题是在应对状态变化时所产生的副作用。从Flux的这篇报道可以很清楚地了解依赖地狱的蠕变：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在这种情况下，你能预测当一个Model发生变化时会发生什么吗？推理是非常非常困难的，因为它的执行次序可能是非常随意的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;模板和显示逻辑被人为地割裂&lt;/p&gt;&#xA;&#xA;&lt;p&gt;视图的作用是什么？呈现的数据显示给用户。ViewModel是干什么的？呈现的数据显示给用户。有什么区别？没有！&lt;/p&gt;&#xA;&#xA;&lt;p&gt;模板分离技术，我不关注〜 皮特·亨特&lt;/p&gt;&#xA;&#xA;&lt;p&gt;最后，一​​个视图组件应该能够操纵它的数据，并能以所希望的格式呈现它。但是，所有的模板语言本质上是残缺的：他们永远不能达到同样的表现力和效能的代码。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;非常简单，&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>你的第一篇博客</title>
      <link>http://webfd.tk/2013/new-born.html</link>
      <pubDate>2013-02-08 12:00:00 +0800</pubDate>
      <description>&lt;h1&gt;感谢你使用Gor编写博客&lt;/h1&gt;&#xA;&#xA;&lt;h2&gt;本文位于 posts/first-blog.md , 你可以任意删掉,修改这个文件&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;文件开头是当前文章的元数据&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;date为自动生成, 当然,你可以修改,这是你的自由&lt;/li&gt;&#xA;&lt;li&gt;permalink 可以是固定地址,也可以由gor为你自动生成&lt;/li&gt;&#xA;&lt;li&gt;categories 就是分类, 可以多个&lt;/li&gt;&#xA;&lt;li&gt;tags 同理,多个标签也是很常见的&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;请确保文件使用UTF8 without BOM编码&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;你可以通过执行下面的语句来新建一篇博客:&lt;/h2&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;gor post 文章标题&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;编译你的博客,并预览之&lt;/h2&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;gor compile #编译&#xA;gor http&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;然后打开你的浏览器,访问 &lt;a href=&#34;http://127.0.0.1:8080&#34;&gt;http://127.0.0.1:8080&lt;/a&gt; 来预览&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;你将使用Markdown来编写博客&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;http://wowubuntu.com/markdown/&#34;&gt;Markdown 语法中文版&lt;/a&gt; 能让你快速入门其语法&lt;/p&gt;&#xA;&#xA;&lt;p&gt;相信&lt;a href=&#34;http://markdownpad.com&#34;&gt;MarkdownPad&lt;/a&gt;或&lt;a href=&#34;http://code.google.com/p/liteide/&#34;&gt;liteide&lt;/a&gt;会是你的编写博客的好帮手&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;如果你打算部署到github的pages上&lt;/h2&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;申请github帐户&lt;/li&gt;&#xA;&lt;li&gt;新建一个库 username.github.com 即你的用户名命名的地址&lt;/li&gt;&#xA;&lt;li&gt;将compiled目录,作为根路径,提交上去github.com上&lt;/li&gt;&#xA;&lt;li&gt;稍等几分钟, 你即可通过 &lt;a href=&#34;http://username.github.com&#34;&gt;http://username.github.com&lt;/a&gt; 访问到&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h2&gt;附上git教程 &lt;a href=&#34;http://gitbook.liuhui998.com/&#34;&gt;GitBook中文版&lt;/a&gt;&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;一般来说,你只需要几个简单的git命令就足以应付大部分需求(仅示例)&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;git clone git://github.com/wendal/wendal.net.git&#xA;git add -A&#xA;git commit -m &amp;quot;...&amp;quot;&#xA;git pull&#xA;git push&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;用gor编写博客将会是一件很开心的事,如果有任何意见或建议,欢迎到 &lt;a href=&#34;http://github.com/wendal/gor&#34;&gt;gor的官网&lt;/a&gt; 提交issue&lt;/h2&gt;&#xA;&#xA;&lt;h1&gt;祝你使用愉快&lt;/h1&gt;&#xA;</description>
    </item>
  </channel>
</rss>